#!/usr/bin/env python3
""" CLI tool for performing cache maintenance on a Yocto sstate-cache. """

import glob
import stat
import os
import re
import argparse as ap
import shlex
import subprocess as sp
from typing import TypedDict, Dict, List, Optional


class FileEntry(TypedDict):
    """ Simplified stat block for describing a file. Only contains values
    that are relevant for us. """

    filename: str
    mtime: float
    atime: float
    size: int


class FileGroup(TypedDict):
    """ Group of files that should be deleted all at once, the combined size of
    all files, and the oldest mtime and atimes of the set."""

    filename: str
    mtime: float
    atime: float
    size: int


def list_files(dirname=".") -> Dict[str, FileEntry]:
    """ Returns a set of FileEntry records that describe all files within
    a folder (or its subfolders). """

    result = {}
    for item in sorted(glob.glob(f"{dirname}/**", recursive=True)):
        stat_data = os.stat(item)

        if not stat.S_ISREG(stat_data.st_mode):
            continue

        result[item] = {
            "filename": item,
            "mtime": stat_data.st_mtime,
            "atime": stat_data.st_atime,
            "size": stat_data.st_size
        }

    return result


def group_related(files: Dict[str, FileEntry]) -> List[FileGroup]:
    """ Takes a dict of FileEntry records (as generated by list_files), and
    splits them into groups that include a siginfo file and the relevant file
    that goes with it. This gives a convenient deletion-point during LRU
    expiration. """

    result = []

    while files:
        group = []
        key = next(iter(files.keys()))
        group.append(files.pop(key))

        if key.endswith(".siginfo"):
            base_file = key[0:-len(".siginfo")]
            if base_file in files:
                group.append(files.pop(base_file))
        else:
            sigfile = key + ".siginfo"
            if sigfile in files:
                group.append(files.pop(sigfile))

        result.append(
            {"files": group}
        )

    for item in result:
        item['size'] = sum(x['size'] for x in item['files'])
        item['mtime'] = min(x['mtime'] for x in item['files'])
        item['atime'] = min(x['atime'] for x in item['files'])

    return result


def select_prune(folder: str, target: int) -> List[FileEntry]:
    """ Returns a list of files to delete from an sstate-cache to prune it
    down to a user-specified size. Files are pruned oldest-first until the
    size-limit is reached. """

    result = []
    groups = group_related(list_files(folder))
    total_size = sum(x['size'] for x in groups)

    while total_size > target:
        if not groups:
            break

        result += groups[0]['files']
        total_size -= groups.pop(0)['size']

    return result


def prune_cmd(args):
    """ Command for removing old files from an sstate-cache until the cache
    gets to a maximum size. """

    prune_list = select_prune(args.path, args.size)

    for filename in [x['filename'] for x in prune_list]:
        if not args.quiet:
            print(f"rm {filename}")
        if not args.dry_run:
            os.unlink(filename)


def directory(arg: str) -> str:
    """ Function used for validating directory locations. Normalizes the
    directory and returns an error if the directory can't be accessed. """

    if arg is None:
        return None

    result = os.path.abspath(arg)

    if not os.path.exists(result):
        raise ValueError(f"unknown directory [{arg}]")

    if not os.path.isdir(result):
        raise ValueError(f"path [{arg}] doesn't point to a directory")

    os.listdir(result)
    return result


def numeric_size(arg: str) -> int:
    """ Function used for converting size arguments from strings to integer
    values. Normalizes for int/float, k/M/G/T suffixes, and ignores B suffixes.
    Designed to be passed as a type to ArgumentParser.add_argument. """

    if arg is None:
        return None

    result = arg.replace(" ", "")
    value = 1

    while result:
        if result[-1] not in 'bBkKmMgGtT':
            break

        if result[-1] in 'kK':
            value *= 1024

        elif result[-1] in 'Mm':
            value *= (1024 * 1024)

        elif result[-1] in 'Gg':
            value *= (1024 * 1024 * 1024)

        elif result[-1] in 'Tt':
            value *= (1024 * 1024 * 1024 * 1024)

        result = result[:-1]

    if not result:
        raise ValueError(f"Couldn't convert {arg} to number")

    value *= float(result)
    return int(value)


class Remote(TypedDict):
    """ Helper-type for our argparse CLI """
    user: Optional[str]
    host: str
    path: str


def remote(arg: str) -> Remote:
    """ Function used for splitting a remote target into user/host/path.
    Suitable for passing as a type to ArgumentParser.add_argument(). """

    if arg is None:
        return None

    regex = "((?P<user>[^ @]+)[@])?(?P<host>[^ @:]+)([:](?P<path>.*))?"
    if not (match := re.search(regex, arg)):
        raise ValueError(f"couldn't parse remote [{arg}]")

    fields = match.groupdict()
    if not fields['path']:
        fields['path'] = '.'

    fields['path'] = os.path.normpath(fields['path'])
    return fields


def ssh_option(arg: str) -> List[str]:
    """ Consumes an SSH option and converts it to a command-line argument to
    pass to SSH. Intended to be used as an argument-type."""

    if arg is None:
        return None

    if "=" not in arg:
        raise ValueError(f"Unknown format [{arg}]. Should be KEY=VALUE")

    key, value = arg.split("=", maxsplit=1)
    return ["-o", f"{key}={value}"]


def update_cmd(args):
    """ Updates a remote cache on a server using rsync and SSH. """

    rsync_cmd = ["rsync", "-a", "--ignore-times", "--checksum",
                 "--delay-updates"]
    ssh_cmd = ["ssh"]

    if args.port:
        ssh_cmd.append(f"-p {args.port}")

    if args.ssh_opts:
        ssh_cmd += [shlex.quote(y) for x in args.ssh_opts for y in x]

    ssh_cmd += ["-o", "StrictHostKeyChecking=no", "-o",
                "UserKnownHostsFile=/dev/null", "-o", "LogLevel=Error"]

    rsync_cmd += ["-e", " ".join(ssh_cmd)]
    dest = f"{args.remote['host']}:{args.remote['path']}"

    if args.remote['user']:
        dest = f"{args.remote['user']}@{dest}"

    rsync_cmd.append(os.path.normpath(args.source) + "/")
    rsync_cmd.append(os.path.normpath(dest))

    if args.dry_run:
        rsync_cmd.append("--dry-run")

    if not args.quiet:
        rsync_cmd += ["-v", "--progress"]
    else:
        rsync_cmd.append("-q")

    if not args.quiet:
        print(" ".join([repr(x) for x in rsync_cmd]), flush=True)

    sp.run(rsync_cmd, check=True)
    dest = re.sub(":.*", "", dest)

    script = f"find . -type f | {' '.join(ssh_cmd)} {dest} "
    script += f"'cd {args.remote['path']} && xargs touch -c'"

    if not args.quiet:
        print(f"cd {args.source} && {script}")

    if not args.dry_run:
        sp.run(script, shell=True, cwd=args.source, check=True)


def parser_add_update(subparsers: ap.ArgumentParser) -> ap.ArgumentParser:
    """ Adds the 'update' subcommand to a subparsers instance. Creates the full
    parser for this particular subcommand. Returns the generated parser,
    although this probably isn't needed by anything. """

    parser = subparsers.add_parser('update', help="""Update a remote cache over
                                   SSH.""")

    parser.set_defaults(cmd=update_cmd)
    parser.description = """Copy a local sstate-cache to a remote server using
                        rsync and SSH. Copies all files in SOURCE to REMOTE
                        using checksum-based rsync, and then touches all of
                        them to adjust the timestamp. """

    parser.add_argument("source", metavar="SOURCE", type=directory,
                        default=".", help="""Local source of cache.""")

    parser.add_argument("remote", metavar="[user@]REMOTE[:PATH]", type=remote,
                        default=".", help="""Remote destination for cache.""")

    parser.add_argument("-n", "--dry-run", action='store_true', help="""Show
                        what would happen without actually doing it.""")

    parser.add_argument("-q", "--quiet", action='store_true', help="""Don't
                        print any informational messages""")

    parser.add_argument("-p", "--port", type=int, help="""SSH port on remote
                        machine.""")

    parser.add_argument("-o", dest="ssh_opts", metavar="KEY=VALUE",
                        action="append", help="""Additional SSH option. Can be
                        specified multiple times.""", default=[],
                        type=ssh_option)

    return parser


def parser_add_prune(subparsers: ap.ArgumentParser) -> ap.ArgumentParser:
    """ Adds the 'prune' subcommand to a subparsers instance. Creates the full
    parser for this particular subcommand. Returns the generated parser,
    although this probably isn't needed by anything. """

    parser = subparsers.add_parser('prune', help="""Prune files from a local
    cache.""")

    parser.set_defaults(cmd=prune_cmd)
    parser.description = """Deletes the oldest files in a directory until the
    directory's contents are below a target size. Intended to be run locally
    on a sstate-cache server."""

    parser.add_argument("path", nargs="?", metavar="PATH", type=directory,
                        default=".", help="""Target path to prune (default:
                        current directory).""")

    parser.add_argument("-n", "--dry-run", action='store_true', help="""Print
                        the files to delete, but don't actually delete
                        them.""")

    parser.add_argument("-q", "--quiet", action='store_true', help="""Don't
                        print any informational messages""")

    parser.add_argument("-s", "--size", type=numeric_size, default="20G",
                        help="""Target size of PATH. Files will be deleted
                        until PATH is approximately that size. Can be specified
                        with k/M/G/T suffixes if desired (default: 20G).""")

    return parser


def make_parser() -> ap.ArgumentParser:
    """ Create an ArgumentParser instance that defines the tool's CLI. """

    parser = ap.ArgumentParser()
    parser.description = """Yocto sstate-cache management tool."""

    subparsers = parser.add_subparsers(metavar="COMMAND", dest="command",
                                       required=True)

    parser_add_prune(subparsers)
    parser_add_update(subparsers)
    return parser


def main():
    """ Entry-point into the CLI. """
    parser = make_parser()
    args = parser.parse_args()
    args.parser = parser

    debug_flag = os.environ.get("DEBUG", "0").strip().lower()
    if debug_flag in ("1", "yes,", "true", "t"):
        return args.cmd(args)

    try:
        return args.cmd(args)
    except Exception as err:
        err_msg = str(err) + "\n" + repr(err)
        err_msg = err_msg.strip()
        args.parser.exit(1, err_msg + "\n")
        raise err  # note; this should be inaccessible.


if __name__ == "__main__":
    main()
